{"version":3,"sources":["App.tsx","serviceWorkerRegistration.ts","reportWebVitals.ts","index.tsx"],"names":["DIRECTIONS_OPTIONS","suppressMarkers","preserveViewport","directionsRequest","DirectionsService","origin","destination","Promise","resolve","reject","route","window","google","maps","LatLng","lat","lon","travelMode","TravelMode","DRIVING","provideRouteAlternatives","result","status","DirectionsStatus","OK","containerStyle","width","height","center","lng","computeTotalElavation","ElavationService","myroute","a","getElevationAlongPath","path","overview_path","samples","res","console","log","App","isLoaded","useJsApiLoader","id","googleMapsApiKey","React","useState","setMap","directions","setDirections","directions2","setDirections2","onLoad","useCallback","map","bounds","LatLngBounds","fitBounds","ElevationService","directionsResult1","directionsResult2","routes","onUnmount","mapContainerStyle","zoom","options","streetViewControl","mapTypeControl","_","k","routeIndex","memo","Boolean","location","hostname","match","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.c1ef861d.chunk.js","sourcesContent":["import React from 'react';\nimport './App.css';\nimport {\n  GoogleMap, useJsApiLoader,\n  DirectionsRenderer,\n} from '@react-google-maps/api';\n\nconst DIRECTIONS_OPTIONS = { suppressMarkers: true, preserveViewport: true }\n\n\n\nconst directionsRequest = ({ DirectionsService, origin, destination }: {\n  DirectionsService: any, origin: { lat: number, lon: number }, destination: { lat: number, lon: number }\n}) =>\n  new Promise((resolve, reject) => {\n    DirectionsService.route(\n      {\n        origin: new window.google.maps.LatLng(origin.lat, origin.lon),\n        destination: new window.google.maps.LatLng(\n          destination.lat,\n          destination.lon\n        ),\n        travelMode: window.google.maps.TravelMode.DRIVING,\n        provideRouteAlternatives: true\n      },\n      (result: unknown, status: google.maps.DirectionsStatus) => {\n        if (status === window.google.maps.DirectionsStatus.OK) {\n          resolve(result)\n        } else {\n          reject(status)\n        }\n      }\n    )\n  })\n\nconst containerStyle = {\n  width: '100vw',\n  height: '100vh'\n};\n\nconst center = { lat: -32, lng: 116 }\n\nconst DIRECTION_REQUEST_DELAY = 300\n\nconst delay = (time: number) =>\n  new Promise<void>((resolve) => {\n    setTimeout(() => {\n      resolve()\n    }, time)\n  })\n\n\n//Map Key\n//AIzaSyAwFPLZIa-3fk07Hq0sAjyaPvYOMTfzyBo\n\nfunction computeTotalDistance(myroute: any) {\n  let total = 0;\n\n  if (!myroute) {\n    return;\n  }\n\n  for (let i = 0; i < myroute.legs.length; i++) {\n    total += myroute.legs[i]!.distance!.value;\n  }\n\n  return total / 1000;\n}\n\nasync function computeTotalElavation(ElavationService: any, myroute: any) {\n  if (!myroute) {\n    return;\n  }\n  const res = await ElavationService.getElevationAlongPath({\n    path: myroute.overview_path,\n    samples: 256,\n  })\n  console.log({ res })\n\n  \n\n  return res\n}\n\nfunction App() {\n  const { isLoaded } = useJsApiLoader({\n    id: 'google-map-script',\n    googleMapsApiKey: \"AIzaSyAwFPLZIa-3fk07Hq0sAjyaPvYOMTfzyBo\"\n  })\n\n  const [map, setMap] = React.useState(null)\n  const [directions, setDirections] = React.useState<any>({})\n  const [directions2, setDirections2] = React.useState<any>({})\n\n  const onLoad = React.useCallback(async function callback(map) {\n    const bounds = new window.google.maps.LatLngBounds();\n    map.fitBounds(bounds);\n    const DirectionsService = new window.google.maps.DirectionsService()\n    const ElavationService = new window.google.maps.ElevationService()\n    console.log(ElavationService.getElevationAlongPath)\n    const directionsResult1 = await directionsRequest({\n      DirectionsService,\n      origin: {\n        lat: -32,\n        lon: 116,\n      },\n      destination: {\n        lat: -33,\n        lon: 116,\n      },\n    })\n\n    const directionsResult2 = await directionsRequest({\n      DirectionsService,\n      origin: {\n        lat: -33,\n        lon: 116,\n      },\n      destination: {\n        lat: -32,\n        lon: 116,\n      },\n    })\n\n    //@ts-ignore\n    const r = await computeTotalElavation(ElavationService, directionsResult1?.routes[0])\n    console.log({ directionsResult1 })\n\n    setDirections(directionsResult1)\n    setDirections2(directionsResult2)\n\n    setMap(map)\n  }, [])\n\n\n  // React.useEffect(() => {\n  //   const DirectionsService = new window.google.maps.DirectionsService()\n  //   const fetchDirections = async () => {\n  //     const selectedOrHoveredOrigin = origins.find(\n  //       ({ id }) => selectedOrHoveredOriginId === id\n  //     )\n  //     const tempDirectionsToOrigin = []\n  //     for (const destination of destinations) {\n  //       const direction = await directionsRequest({\n  //         DirectionsService,\n  //         origin: {\n  //           lat: selectedOrHoveredOrigin.coordinates.lat,\n  //           lon: selectedOrHoveredOrigin.coordinates.lon,\n  //         },\n  //         destination: {\n  //           lat: destination.coordinates.lat,\n  //           lon: destination.coordinates.lon,\n  //         },\n  //       })\n  //       await delay(DIRECTION_REQUEST_DELAY)\n  //       tempDirectionsToOrigin.push(direction)\n  //     }\n  //     setDirections((prevState) => ({\n  //       ...prevState,\n  //       [selectedOrHoveredOriginId]: tempDirectionsToOrigin,\n  //     }))\n  //   }\n  //   fetchDirections()\n\n  // }, [\n  //   destinations,\n  //   directionsToSelectedOrHoveredOrigin,\n  //   selectedOrHoveredOriginId,\n  //   origins,\n  // ])\n\n  const onUnmount = React.useCallback(function callback(map) {\n    setMap(null)\n  }, [])\n\n  return isLoaded ? (\n    <GoogleMap\n      mapContainerStyle={containerStyle}\n      center={center}\n      zoom={10}\n      onLoad={onLoad}\n      onUnmount={onUnmount}\n      options={{ streetViewControl: false, mapTypeControl: false }}\n    >\n      {directions &&\n        directions.routes && directions.routes.map((_: unknown, k: number) =>\n          <DirectionsRenderer\n            key={`route-${k}`}\n            routeIndex={k}\n            directions={directions}\n            options={DIRECTIONS_OPTIONS}\n          />)\n      }\n      {directions2 &&\n        directions2.routes && directions2.routes.map((_: unknown, k: number) =>\n          <DirectionsRenderer\n            key={`route-2-${k}`}\n            routeIndex={k}\n            directions={directions2}\n            options={DIRECTIONS_OPTIONS}\n          />)\n      }\n      { /* Child components, such as markers, info windows, etc. */}\n      <></>\n    </GoogleMap>\n  ) : <></>\n}\n\nexport default React.memo(App)","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(/^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/)\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log('No internet connection found. App is running in offline mode.');\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://cra.link/PWA\nserviceWorkerRegistration.unregister();\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}